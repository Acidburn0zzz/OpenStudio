# see the URL below for information on how to write OpenStudio measures
# http://openstudio.nrel.gov/openstudio-measure-writing-guide

require 'openstudio'
require 'optparse'
require 'json'


# start the measure
class ReportRequest < OpenStudio::Ruleset::WorkspaceUserScript
  
  def initialize
    super
    
    # DLM: mirrors code in UserScriptAdapter.rb, refactor
    @options = Hash.new
    @options[:arguments] = []

    @optparse = OptionParser.new do |opts|

      opts.on('-u','--userScript USERSCRIPT', String, "Path to .rb file that contains an OpenStudio::Ruleset::UserScript" ) do |userScript|
        @options[:userScript] = userScript
      end
      
      opts.on('-i','--inputPath INPUTPATH', String, "Path to input model (OpenStudio::Model::Model or OpenStudio::Workspace)." ) do |inputPath|
        @options[:inputPath] = inputPath
      end
      
      opts.on('-o','--outputPath OUTPUTPATH', String, "Output file to write (OpenStudio::Model::Model or OpenStudio::Workspace)." ) do |outputPath|
        @options[:outputPath] = outputPath
      end
      
      opts.on('-s','--lastOpenStudioModelPath LASTOPENSTUDIOMODELPATH', String, "Path to last OpenStudio Model generated by this workflow." ) do |lastOpenStudioModelPath|
        @options[:lastOpenStudioModelPath] = lastOpenStudioModelPath
      end
        
      opts.on('-s','--lastEnergyPlusWorkspacePath LASTENERGYPLUSWORKSPACEPATH', String, "Path to last EnergyPlus Workspace generated by this workflow." ) do |lastEnergyPlusWorkspacePath|
        @options[:lastEnergyPlusWorkspacePath] = lastEnergyPlusWorkspacePath
      end
        
      opts.on('-s','--lastEnergyPlusSqlFilePath LASTENERGYPLUSSQLFILEPATH', String, "Path to last EnergyPlus SqlFile generated by this workflow." ) do |lastEnergyPlusSqlFilePath|
        @options[:lastEnergyPlusSqlFilePath] = lastEnergyPlusSqlFilePath
      end
      
      opts.on('-s','--lastEpwFilePathArgument LASTEPWFILEPATH', String, "Path to last EpwFile generated by this workflow." ) do |lastEpwFilePath|
        @options[:lastEpwFilePath] = lastEpwFilePath
      end
      
      opts.on('-n','--argumentName ARGUMENTNAME', String, "Name of next argument.") do |argumentName|
        @options[:tempName] = argumentName
      end
      
      opts.on('-v','--argumentValue ARGUMENTVALUE', String, "Value of next argument.") do |argumentValue|
        #puts "Found argument '" + options[:tempName] + "' with value '" + argumentValue + "'."
        argValPair = [@options[:tempName].to_s, argumentValue]
        @options[:arguments].push(argValPair)
      end 
    end
  end
  
  
  # human readable name
  def name
    return "Report Request"
  end

  # human readable description
  def description
    return "Requests EnergyPlus output reports based on downstream reporting measures."
  end
  
  # human readable description of modeling approach
  def modeler_description
    return ""
  end
  
  # define the arguments that the user will input
  def arguments(workspace)
    args = OpenStudio::Ruleset::OSArgumentVector.new
    
    json_work_items = OpenStudio::Ruleset::OSArgument::makeStringArgument("json_work_items", true)
    args << json_work_items
    
    return args
  end
  
  # examines object and determines whether or not to add it to the workspace
  def add_object(runner, workspace, idf_object)
    num_added = 1
    
    runner.registerInfo("Adding idf object #{idf_object}")
    workspace.addObject(idf_object)
    
    return num_added
  end

  # define what happens when the measure is run
  def run(workspace, runner, user_arguments)
    super(workspace, runner, user_arguments)
    
    # use the built-in error checking 
    if not runner.validateUserArguments(arguments(workspace), user_arguments)
      return false
    end

    # assign the user inputs to variables
    json_work_items = runner.getStringArgumentValue("json_work_items", user_arguments)
    
    File.open('example.json', 'w') do |f|
      f << json_work_items
    end
    
    json_work_items = JSON.parse(json_work_items)
    
    runner.registerInfo("Examining report requests from #{json_work_items.size} reporting measures")
    
    error = false
    num_added = 0
    json_work_items.each do |json_work_item|
      begin
        #work_item = OpenStudio::Runmanager::WorkItem.fromJSON(json_work_item.to_s)
        #measure_file = work_item.files.getLastByFilename("measure.rb")
        
        measure_file = nil
        json_work_item["required_files"].each do |required_file|
          if measure_file = required_file["measure.rb"]
            break
          end
        end
        
        if measure_file.nil?
          error = true
          runner.registerError("Measure does not specify a script file")
          next
        elsif not File.exists?(measure_file.to_s)
          error = true
          runner.registerError("Measure file '#{measure_file}' does not exist")
          next
        else
          runner.registerInfo("Loading measure file '#{measure_file}'")
        end

        # Check list of objects in memory before loading the script
        currentObjects = Hash.new
        ObjectSpace.each_object(OpenStudio::Ruleset::UserScript) { |obj| currentObjects[obj] = true }
        ObjectSpace.garbage_collect
        
        load measure_file.to_s # need load in case have seen this script before
        userScript = nil
        type = String.new
        ObjectSpace.each_object(OpenStudio::Ruleset::UserScript) do |obj|
          if not currentObjects[obj]
            if obj.is_a? OpenStudio::Ruleset::ReportingUserScript
              userScript = obj
              type = "report"
            end
          end
        end
        
        if userScript.nil?
          error = true
          runner.registerInfo("Measure at '#{measure_file}' does not appear to be a reporting measures")
          next
        end
 
        # DLM: this code mirrors that in UserScriptAdapter, refactor out somewhere
        parameters = json_work_item["parameters"]
        
        @options.clear
        @options[:arguments] = []
        @optparse.parse(parameters)
        userArguments = @options[:arguments]
        
        #puts "parameters = #{parameters}"
        #puts "@options = #{@options}"
        #puts "userArguments = #{userArguments}"
        
        arguments = OpenStudio::Ruleset::OSArgumentMap.new
        userScript.arguments().each do |arg|
        
          puts "Looking for #{arg}"
        
          # look for arg.name() in options
          userArg = nil
          userArguments.each do |candidate|
            if candidate[0] == arg.name
              userArg = candidate
              break
            end
          end
            
          # if found, set
          if userArg
            arg.setValue(userArg[1])
          end
            
          arguments[arg.name] = arg
        end
        
        idf_objects = userScript.energyPlusOutputRequests(runner, arguments)
        
        idf_objects.each do |idf_object|
          num_added += add_object(runner, workspace, idf_object)
        end
        
      rescue Exception => e
        error = true
        runner.registerError("#{e.message}\n#{e.backtrace}")
      end
    end
    
    if error
      return false
    end
    
    runner.registerFinalCondition("Added #{num_added} output requests for reporting measures")

    return true
 
  end 

end 

# register the measure to be used by the application
ReportRequest.new.registerWithApplication