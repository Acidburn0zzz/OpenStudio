# see the URL below for information on how to write OpenStudio measures
# http://openstudio.nrel.gov/openstudio-measure-writing-guide

require 'openstudio'
require 'optparse'
require 'json'


# start the measure
class ReportRequest < OpenStudio::Ruleset::WorkspaceUserScript
  
  def initialize
    super
    
    # DLM: mirrors code in UserScriptAdapter.rb, refactor
    @options = Hash.new
    @options[:arguments] = []

    @optparse = OptionParser.new do |opts|

      opts.on('-u','--userScript USERSCRIPT', String, "Path to .rb file that contains an OpenStudio::Ruleset::UserScript" ) do |userScript|
        @options[:userScript] = userScript
      end
      
      opts.on('-i','--inputPath INPUTPATH', String, "Path to input model (OpenStudio::Model::Model or OpenStudio::Workspace)." ) do |inputPath|
        @options[:inputPath] = inputPath
      end
      
      opts.on('-o','--outputPath OUTPUTPATH', String, "Output file to write (OpenStudio::Model::Model or OpenStudio::Workspace)." ) do |outputPath|
        @options[:outputPath] = outputPath
      end
      
      opts.on('-s','--lastOpenStudioModelPath LASTOPENSTUDIOMODELPATH', String, "Path to last OpenStudio Model generated by this workflow." ) do |lastOpenStudioModelPath|
        @options[:lastOpenStudioModelPath] = lastOpenStudioModelPath
      end
        
      opts.on('-s','--lastEnergyPlusWorkspacePath LASTENERGYPLUSWORKSPACEPATH', String, "Path to last EnergyPlus Workspace generated by this workflow." ) do |lastEnergyPlusWorkspacePath|
        @options[:lastEnergyPlusWorkspacePath] = lastEnergyPlusWorkspacePath
      end
        
      opts.on('-s','--lastEnergyPlusSqlFilePath LASTENERGYPLUSSQLFILEPATH', String, "Path to last EnergyPlus SqlFile generated by this workflow." ) do |lastEnergyPlusSqlFilePath|
        @options[:lastEnergyPlusSqlFilePath] = lastEnergyPlusSqlFilePath
      end
      
      opts.on('-s','--lastEpwFilePathArgument LASTEPWFILEPATH', String, "Path to last EpwFile generated by this workflow." ) do |lastEpwFilePath|
        @options[:lastEpwFilePath] = lastEpwFilePath
      end
      
      opts.on('-n','--argumentName ARGUMENTNAME', String, "Name of next argument.") do |argumentName|
        @options[:tempName] = argumentName
      end
      
      opts.on('-v','--argumentValue ARGUMENTVALUE', String, "Value of next argument.") do |argumentValue|
        #puts "Found argument '" + options[:tempName] + "' with value '" + argumentValue + "'."
        argValPair = [@options[:tempName].to_s, argumentValue]
        @options[:arguments].push(argValPair)
      end 
    end
  end

  # human readable name
  def name
    return "Report Request"
  end

  # human readable description
  def description
    return "Requests EnergyPlus output reports based on downstream reporting measures."
  end
  
  # human readable description of modeling approach
  def modeler_description
    return ""
  end
  
  # define the arguments that the user will input
  def arguments(workspace)
    args = OpenStudio::Ruleset::OSArgumentVector.new
    
    measures_json = OpenStudio::Ruleset::OSArgument::makeStringArgument("measures_json", true)
    args << measures_json
    
    return args
  end
  
  # examines object and determines whether or not to add it to the workspace
  def add_object(runner, workspace, idf_object)
    num_added = 1
    
    runner.registerInfo("Adding idf object #{idf_object}")
    workspace.addObject(idf_object)
    
    return num_added
  end

  # define what happens when the measure is run
  def run(workspace, runner, user_arguments)
    super(workspace, runner, user_arguments)
    
    # use the built-in error checking 
    if not runner.validateUserArguments(arguments(workspace), user_arguments)
      return false
    end

    # assign the user inputs to variables
    measures_json = runner.getStringArgumentValue("measures_json", user_arguments)
    
    File.open('example.json', 'w') do |f|
      f << measures_json
    end
    
    measures_json = JSON.parse(measures_json)
    
    runner.registerInfo("Examining report requests from #{measures_json.size} measures")
    
    error = false
    num_added = 0
    measures_json.each do |measure_json|
      begin
        #work_item = OpenStudio::Runmanager::WorkItem.fromJSON(json_work_item.to_s)
        #measure_file = work_item.files.getLastByFilename("measure.rb")
        
        measure_file = measure_json["measure"]
        
        if measure_file.nil?
          error = true
          runner.registerError("Measure does not specify a script file")
          next
        elsif not File.exists?(measure_file.to_s)
          error = true
          runner.registerError("Measure file '#{measure_file}' does not exist")
          next
        else
          runner.registerInfo("Loading measure file '#{measure_file}'")
        end

        # Check list of objects in memory before loading the script
        currentObjects = Hash.new
        ObjectSpace.each_object(OpenStudio::Ruleset::UserScript) { |obj| currentObjects[obj] = true }
        ObjectSpace.garbage_collect
        
        load measure_file.to_s # need load in case have seen this script before
        userScript = nil
        type = String.new
        ObjectSpace.each_object(OpenStudio::Ruleset::UserScript) do |obj|
          if not currentObjects[obj]
            if obj.is_a? OpenStudio::Ruleset::ReportingUserScript
              userScript = obj
              type = "report"
            end
          end
        end
        
        if userScript.nil?
          error = true
          runner.registerInfo("Measure at '#{measure_file}' does not appear to be a reporting measures")
          next
        end
 
        arguments = OpenStudio::Ruleset::OSArgumentMap.new
        if parameters = measure_json["parameters"]
        
          # DLM: this code mirrors that in UserScriptAdapter, refactor out somewhere
          # DLM: Nick this code would be different for the server as you would not likely want to populate 'parameters' the same way, you could populate 'arguments' instead
          @options.clear
          @options[:arguments] = []
          @optparse.parse(parameters)
          userArguments = @options[:arguments]
    
          userScript.arguments().each do |arg|
          
            puts "Looking for #{arg}"
          
            # look for arg.name() in options
            userArg = nil
            userArguments.each do |candidate|
              if candidate[0] == arg.name
                userArg = candidate
                break
              end
            end
              
            # if found, set
            if userArg
              arg.setValue(userArg[1])
            end
              
            arguments[arg.name] = arg
          end
          
        elsif arguments = measure_json["arguments"]
        
          # DLM: Nick look here
          
        end
        
        idf_objects = userScript.energyPlusOutputRequests(runner, arguments)
        
        idf_objects.each do |idf_object|
          num_added += add_object(runner, workspace, idf_object)
        end
        
      rescue Exception => e
        error = true
        runner.registerError("#{e.message}\n#{e.backtrace}")
      end
      
    end
    
    if error
      return false
    end
    
    runner.registerFinalCondition("Added #{num_added} output requests for reporting measures")

    return true
 
  end 

end 

# register the measure to be used by the application
ReportRequest.new.registerWithApplication